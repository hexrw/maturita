<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/x-icon" href="/favicon.svg">

        <link rel="stylesheet" href="/assets/pico.css">
        <link rel="stylesheet" href="/assets/prism.css">
        <style>
            img:not([data-img-type="icon"]) {
                margin: auto;
                display: block;
            }
            li {
                margin-left: 1rem;
            }
        </style>
    </head>
    <body>
        <div class="container" style="padding-top: 1.5rem;">
            <header>
                <h1><a href="http://localhost:4000/">Maturita</a></h1>

                

                <p>Otázky k maturitě</p>
            </header>

            <hr style="margin: 2rem 0;">

            
            <div style="display: inline-flex; gap: 2rem; flex-wrap: wrap;">
                <a class="outline" style="cursor: pointer;" onclick="window.history.back()">
                    <img src="/assets/arrow-left.svg" alt="Zpět" style="width: 1.5rem; height: 1.5rem;">
                </a>
                <div id="breadcrumbs">
    
    <a href="/">Domů</a>
    
        
            / <a href="/informatika/">Informatika</a>
        
    
        
            / Základní metody vyhledávání a třídění
        
    
</div>
            </div>
            <hr style="margin: 2rem 0;">
            


            
                <h1>Základní metody vyhledávání a třídění</h1>
            

            <section>

            <h2 id="vyhledávání">Vyhledávání</h2>

<h3 id="vyhledávání-v-poli">Vyhledávání v poli</h3>

<h4 id="lineární-vyhledávání">Lineární vyhledávání</h4>

<blockquote>
  <p>Lineární (sekvenční) vyhledávání je nejjednodušším způsobem, jak zjistit, jestli se v poli (nebo jiné datové struktuře) nachází námi hledaný prvek. Princip je zcela triviální, procházíme jeden prvek po druhém a zjišťujeme, jestli to není právě ten, který hledáme. Z tohoto vyplývá složitost tohoto postupu - <strong><em>O(n)</em></strong>.</p>
</blockquote>

<p><strong>Využití</strong> - Lineární vyhledávání použijeme tehdy, pokud nemáme žádné informace o uspořádání prvků struktury nebo pokud nám datová struktura (například spojový seznam) neumožňuje efektivnější způsob vyhledávání.</p>

<h4 id="binární-vyhledávání">Binární vyhledávání</h4>

<blockquote>
  <p>Binární vyhledávání (půlení intervalu) je vyhledávací technika, která zjišťuje pozici zadaného prvku v seřazeném poli. Na rozdíl od sekvenčního vyhledávání, které vyžaduje až O(n) operací, binární vyhledávání pracuje s asymptotickou složitostí <strong><em>O(log<sub>2</sub>(n))</em></strong>.</p>
</blockquote>

<h5 id="princip">Princip</h5>

<p>Mějme sestupně seřazené pole a hledejme v něm prvek h. Binární vyhledávání v každém svém kroku zvolí prostřední prvek pole <strong><em>(p)</em></strong> a porovná jej s prvkem h. Pokud jsou tyto prvky totožné, tak vrátí index prvku p. Pokud má hledaný prvek vyšší hodnotu než <strong><em>p</em></strong>, tak je zřejmé, že h se musí nacházet v levé části pole. V opačném případě <strong><em>(p &gt; h)</em></strong> se hledaný prvek musí nacházet v pravé části pole. Binární vyhledávání proto zavolá sebe sama na příslušnou perspektivní polovinu pole.</p>

<p>Protože dochází v každém kroku k půlení prohledávaného intervalu (a druhá polovina se nezpracovává), tak musí dojít k nalezení (nebo vyvrácení přítomnosti) hledaného prvku nejpozději v <strong><em>log<sub>2</sub>(n)</em></strong> krocích.</p>

<h4 id="interpolační-vyhledávání">Interpolační vyhledávání</h4>

<blockquote>
  <p>Interpolační vyhledávání je vylepšením binárního vyhledávání pro případ, kdy víme, že jsou čísla v poli nejen seřazená, ale také rovnoměrně rozložená.</p>
</blockquote>

<p><strong>Princip</strong> - Interpolační vyhledávání vychází z úvahy, že pokud máme v poli například čísla od 0 do 100 a hledáme číslo 2, tak je přinejmenším nerozumné pole binárně dělit (napřed se podívat na index 50, pak 25, pak 12…), ale je daleko rozumnějsí se podívat někam kolem indexu 2, kde by se číslo mělo nacházet (vzhledem k rovnoměrnému rozložení). Složitost tohoto přístupu je <strong><em>O(log(log(n))</em></strong>.</p>

<h4 id="prořezávej-a-hledej">Prořezávej a hledej</h4>

<blockquote>
  <p>Prořezávej a hledej (<em>Prune and search</em>) je typ algoritmu založený na vyřazování neperspektivních dat – redukci velikosti problému. Toto paradigma je velmi podobné algoritmům typu rozděl a panuj (<em>divide and conquer</em>), zásadní rozdíl je ovšem v tom, že při prořezávání neprocházíme všechny větve, ale pouze ty, které pro nás dávají smysl.</p>
</blockquote>

<p><strong>Příklad</strong> - Pokud hledáme n-té nejvyšší číslo v neseřazeném poli, tak by řešením zajisté bylo pole seřadit a podívat se na zadaný index. Toto řešení ovšem není příliš efektivní. Lepším řešením je upravit například Quicksort tak, aby se po rozdělení pole dle pivota prohledávala pouze ta část, která obsahuje řešení - Quicksort v každém svém kroku umístí pivota na korektní místo v seřazeném poli, není proto problém rozhodnout, ve které části se nachází ono hledané číslo.</p>

<p><strong>Složitost</strong> - Zatímco <a href="/informatika/algoritmus-vyvojove-diagramy-deklarace-promennych/#asymptotická-složitost-algoritmu">asymptotická složitost</a> Quicksortu je <strong><em>O(n<sup>2</sup>)</em></strong> a očekáváná <strong><em>O(n * log(n))</em></strong>, tak díky eliminaci větví, které nemohou obsahovat řešení, je očekávaná složitost prune and search algoritmu <strong><em>O(c * n)</em></strong>, kde c je malá konstanta.</p>

<h3 id="vyhledávání-v-textu">Vyhledávání v textu</h3>

<h4 id="naivní-algoritmus">Naivní algoritmus</h4>

<h4 id="hammingova-vzdálenost">Hammingova vzdálenost</h4>

<h4 id="levenshteinova-vzdálenost">Levenshteinova vzdálenost</h4>

<h2 id="třídění">Třídění</h2>

<h4 id="bubble-sort">Bubble sort</h4>

<h4 id="selection-sort">Selection sort</h4>

<h4 id="insertion-sort">Insertion sort</h4>

<h4 id="quicksort">Quicksort</h4>

<h4 id="merge-sort">Merge sort</h4>

<h4 id="heapsort">Heapsort</h4>

<h4 id="shaker-sort">Shaker sort</h4>

<h4 id="counting-sort">Counting sort</h4>

<h4 id="radix-sort">Radix sort</h4>

<h4 id="bucket-sort">Bucket sort</h4>

<h4 id="shell-sort">Shell sort</h4>

<h4 id="bogosort">Bogosort</h4>

<h4 id="comb-sort">Comb sort</h4>

<h4 id="dropsort">DropSort</h4>

<h4 id="block-merge-sort">Block Merge Sort</h4>



            

            </section>

            <hr style="margin: 2rem 0;">

            <footer>
                
                <p>Projekt spravuje <a target="_blank" href="https://github.com/hex2w">Petr Kolonicz</a></p>
                
            </footer>
        </div>

        <script src="/assets/prism.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>
        <script>
        
        anchors.add("h1, h2, h3, h4, h5, h6")
        
        </script>
    </body>
</html>
